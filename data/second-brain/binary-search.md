# Binary Search

- Requires array to be sorted
- Divide and conquer

## Complexity

- Time
  - $O(log(n))$
  - Split the search space by two on every iteration

## Process

- Start by searching in the middle
- If what you are looking for is _smaller_ than what you find in the middle, restrict search up to the middle
- If what you are looking for is _bigger_ than what you find in the middle, restrict search space from middle on
- Repeat until you find what you're looking for or your search space has nothing in it

## Implementations

### JavaScript

```javascript
const target = 14;
const sortedArray = [2, 4, 6, 8, 10, 12, 14, 16];

// Start the search space with the entire array
let startIndex = 0;
let endIndex = sortedArray.length - 1;

// While the search space has elements in it...
while (startIndex <= endIndex) {
  // Grab the middle, acounting for a min (startIndex)
  const middleIndex = startIndex + Math.floor((endIndex - startIndex) / 2);

  // Target found!
  if (sortedArray[middleIndex] === target) {
    return middleIndex;
  }

  if (sortedArray[middleIndex] < target) {
    // Middle is less than target
    // Adjust search space to second half of current search space
    startIndex = middleIndex + 1;
  } else {
    // Middle is greater than target
    // Adjust search space to first half of current space
    endIndex = middleIndex - 1;
  }

  return -1;
}
```

[[Computer Science]] [[Algorithm]]

[//begin]: # "Autogenerated link references for markdown compatibility"
[Computer Science]: computer-science "Computer Science"
[Algorithm]: algorithm "Algorithm"
[//end]: # "Autogenerated link references"